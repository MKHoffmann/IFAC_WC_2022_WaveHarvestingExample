function [ocp,x,u,d,x0_p] = initializeOCP(timehorizon,dt,args)
arguments
    timehorizon  (1,1) {mustBeNumeric}
    dt           (1,1) {mustBeNumeric}
    args.solver  (1,:) {mustBeText} = 'ipopt'
    args.foh     (1,1) logical = true
    args.x0      (7,1) {mustBeNumeric} =  [0.0515     0.1392   314.4363   94.1062  190.4844         0         0 ]';
    args.nx      (1,1) {mustBeNumeric}  = 7;
    args.nu      (1,1) {mustBeNumeric}  = 1;

end


global PathToParameters 
% Number of increments is timehorizon/dt (+1 if foh)
nSteps =round(timehorizon/(dt));
%% Construct the OCP 
% The simulation is started with the flap already in motion. The initial
% state x0 represents the state after 100 seconds of swing in. 
x0 = args.x0;  

nx=args.nx;     %Number of states in x
nu=args.nu;     %Number of states in u
foh=args.foh;    %First order hold activated

%Construct the basic OCP from the ODE . only return the ode
%object. Will not apply disturbance and cost function. 

import casadi.*
ocp = casadi.Opti();
ocp.solver('ipopt')
%Load material/system parameters
load(PathToParameters ,'Ac', 'Bc', 'gamma','R0');


%The wave differenctial equation with 
% x(1)   = first derivative of angle 
% x(2)   = angle of the flap 
% x(3-5) = is a state vector describing the waves generated by the device with its own motion
% x(6)   = Energy Harvested
% x(7)   = Damage aculmulated

wave_dgl = @(x,u,d) [Ac * x(1:5) - Bc * 1e6 * u * gamma * x(2) + Bc * d;
                            cost_energy(x,u,d);
                            cost_damage(x,u);
                            ];
% Box constraints on input are 
x_box = [-Inf Inf; -Inf, Inf; -Inf Inf; -Inf, Inf; -Inf, Inf;-Inf, Inf;-Inf, Inf;-Inf, Inf;-Inf, Inf;-Inf, Inf;-Inf, Inf;-Inf, Inf];
u_box = [0 33^2];

x0_p = ocp.parameter(nx,1);
x = [x0_p, ocp.variable(nx, nSteps+1 - (foh))];
u = [ocp.parameter(nu, 1), ocp.variable(nu, nSteps)];
d = ocp.parameter(1, nSteps + foh);
h_integ = casadi.MX(nx, nSteps);

for iStep = 1:nSteps
        h_integ(:, iStep) = integrator_step_disturbed(x(:,iStep), u(:, iStep + (0:foh)), dt, wave_dgl, d(:, iStep + (0:foh))) - x(:,iStep+1);
        ocp.subject_to( )
end
h_zero = h_integ(:) == 0;
ocp.subject_to( h_zero )




ocp.set_value(u(1),0);       %% first value for u has to be zero. 

ocp.set_value(x0_p,x0);


    g_u_lower = u_box(:, 1) - u(:);
    g_u_upper = u(:) - u_box(:, 2);
    g_u = [g_u_lower(:); g_u_upper(:)];
    g_u_constr = g_u <= 0;
    ocp.subject_to(g_u_constr)

end


function x_end = integrator_step_disturbed(x0, u, dt, odefun, d)
% calculate one integration step with step size dt
import casadi.*

x0_rk = x0;
k = casadi.MX( size( x0, 1 ), 4 );

if size(u,2) == 1
    k(:,1) = odefun(x0_rk(:,end)                  , u, d);
    k(:,2) = odefun(x0_rk(:,end) + dt / 2 * k(:,1), u, d);
    k(:,3) = odefun(x0_rk(:,end) + dt / 2 * k(:,2), u, d);
    k(:,4) = odefun(x0_rk(:,end) + dt     * k(:,3), u, d);
else
    k(:,1) = odefun(x0_rk(:,end)                  , u(:,1),       d(:,1));
    k(:,2) = odefun(x0_rk(:,end) + dt / 2 * k(:,1), u*[0.5; 0.5], d*[0.5; 0.5]);
    k(:,3) = odefun(x0_rk(:,end) + dt / 2 * k(:,2), u*[0.5; 0.5], d*[0.5; 0.5]);
    k(:,4) = odefun(x0_rk(:,end) + dt     * k(:,3), u(:,2),       d(:,2));
end

x_end  = x0_rk + dt / 6 * k * [1 2 2 1]';

end
%%
% function xdot = wave_dgl(x,u,d)
% 
% 
% import casadi.*
% 
% load('/home/heib/Documents/HIWI/FlaÃŸkamp/WaveHarvesting/DEA-Wave-Harvesting/PolySurge_inputs.mat', 'Ac', 'Bc', 'gamma');
% 
% slacks = MX;
% 
% % definition ode
% %  xdot = @(x, u, d, slacks) [Ac * x(1:5) - Bc * 1e6 * u * gamma * x(2) + Bc * d;
% %                      cost_energy(x, u, d, slacks)];
%                    xdot =  @(x,u,d) Ac * x - Bc * 1e6 * u * gamma * x(2) + Bc * d;

% end


function cost = cost_energy(x, u, d)
    persistent Ch S R0
    global PathToParameters
    if isempty(Ch) || isempty(S) || isempty(R0)
        load(PathToParameters ,'Ch', 'S', 'R0');
    end
    cost = (Ch*x(1).^2 + x(3:5)'*S*x(3:5) - d .* x(1))*1e-6 + u/R0;
end
function E1 = EE1(x, u, d)
    persistent Ch S R0
    global PathToParameters
    if isempty(Ch) || isempty(S) || isempty(R0)
        load(PathToParameters, 'Ch', 'S', 'R0');
    end
    E1 = 1e-6*(Ch*x(1).^2);
end
function E2 = EE2(x, u, d)
    persistent Ch S R0
    global PathToParameters
    if isempty(Ch) || isempty(S) || isempty(R0)
        load(PathToParameters, 'Ch', 'S', 'R0');
    end
     E2 = (x(3:5)'*S*x(3:5))*1e-6 ;
end
function E3 = EE3(x, u, d)
    persistent Ch S R0
    global PathToParameters
    if isempty(Ch) || isempty(S) || isempty(R0)
        load(PathToParameters, 'Ch', 'S', 'R0');
    end
      E3 = - (d .* x(1))*1e-6;
end
function E4 = EE4(x, u, d)
    persistent Ch S R0
    global PathToParameters
    if isempty(Ch) || isempty(S) || isempty(R0)
        load(PathToParameters, 'Ch', 'S', 'R0');
    end
     E4 = u/R0;
end

function cost = cost_damage(x, u, ~, ~)   
%     cost = (max(u - 484/(cos(x(2)).^2), 0).^2)*1e-6;
    cost = (max(u - 484, 0).^2)*1e-6;
end

